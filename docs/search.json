[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Cheat Sheet",
    "section": "",
    "text": "getwd(): Retrieves the current working directory path.\ninstall.packages(\"tidyverse\"): Installs the tidyverse package.\ninstall.packages(\"dslabs\"): Installs the dslabs package.\nlibrary(tidyverse): Loads the tidyverse package, a collection of R packages designed for data science.\nlibrary(dslabs): Loads the dslabs package, which contains datasets and functions for data science.\nlibrary(ggplot2): Loads the ggplot2 package for creating plots.\ndata(murders): Loads the murders dataset available in the dslabs package.\n\n\n\n\n\n\n\nc(): Combines elements into a vector.\nnames(): Assigns names to vector elements for easier indexing.\n\n\ndays &lt;- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\")\nmy_calories &lt;- c(100, 120, 200, 150, 140)\nnames(my_calories) &lt;- days # Assigns names to the elements in the `my_calories` vector\n\nThis code creates two vectors: one for days and one for calorie count. It then assigns the names of the days as labels for the calorie counts.\n\nmy_vector &lt;- c(1:10): Creates a vector containing a sequence from 1 to 10.\n\n\n\n\n\nBy position: my_calories[1] retrieves the first element.\nBy name: my_calories[\"Monday\"] retrieves the element named “Monday”.\nBy range: my_calories[1:3] retrieves the first three elements.\n\n\nfirst_three_days &lt;- my_calories[1:3] # Selects the first three elements\nmy_calories_monday &lt;- my_calories[\"Monday\"] # Selects the element named \"Monday\"\n\nThis demonstrates how to retrieve specific elements from a vector, either by their position or by their assigned names.\n\nmy_exp[c(1,3)] or my_exp[c(\"MON\",\"WED\")]: Accessing multiple elements using numeric or named indices. Retrieves the first and third elements or retrieves the element named “MON” and “WED”.\n\n\n\n\n\nmy_calories[my_calories &gt;= 150] retrieves elements meeting the condition.\n\n\nmy_good_days &lt;- my_calories[my_calories &gt;= 150] # Selects days with calorie counts of 150 or more\n\nThis is used to create a subset of my_calories where the condition (calories &gt;= 150) is true.\n\n\n\nThe c() function is used again to merge two separate vectors into a single vector.\n\nmy_friends_calories &lt;- c(200, 130, 100, 170, 150)\nall_calories &lt;- c(my_calories, my_friends_calories): Combines two vectors into one.\n\n\n\n\n\nmy_calories &lt;- my_calories + 50: Adding 50 to each element of my_calories vector.\nweekly_calories &lt;- sum(my_calories): Summing all elements of my_calories to get weekly_calories, the total calories.\n\n\n\n\n\n\n\n\nmatrix(): Creates a matrix from the provided vector.\nncol, byrow: Specifies the number of columns and whether to fill the matrix by rows.\nmy_matrix &lt;- matrix(1:9, ncol = 3): Constructs a 3x3 matrix with a sequence of numbers from 1 to 9.\n\n\n\n\n\nrownames(), colnames(): Assigns names to the rows and columns of a matrix.\n\n\ncalories_matrix &lt;- matrix(all_calories, ncol=2, byrow=FALSE)\nrownames(calories_matrix) &lt;- days # Sets the row names of the matrix.\ncolnames(calories_matrix) &lt;- c(\"me\", \"my_friend\") # Sets the column names of the matrix.\n\nThis code block shows how to convert a vector into a matrix and then assign row and column names for better readability.\n\n\n\nLet’s first create a matrix again.\n\nsw_matrix &lt;- matrix(sw, nrow = 3, byrow = TRUE): Creating a matrix sw_matrix from the sw vector, filling the matrix by rows.\nrownames(sw_matrix) &lt;- titles: Setting row names of the matrix sw_matrix.\ncolnames(sw_matrix) &lt;- regions: Setting column names of the matrix sw_matrix.\n\nSummation;\n\ncolSums(sw_matrix) and rowSums(sw_matrix): Calculating the sum of columns and rows in sw_matrix.\nsw_matrix2 &lt;- cbind(sw_matrix, worldwide): Binding a new column worldwide to the sw_matrix to form sw_matrix2.\n\nCombining;\n\nsw2 &lt;- matrix(box_office2, nrow = 3, byrow=TRUE): Creating another matrix sw2.\nallsw &lt;- rbind(sw_matrix, sw2): Combining two matrices by rows, resulting in allsw.\n\n\n\n\n\n\n\n\nas.factor(): Converts a vector into a factor, useful for categorical data.\nlevels: Specifies the levels of the factor.\n\n\ncategorical_vector &lt;- c(\"Male\", \"Female\", \"Female\")\ncategorical_vector_as_factor &lt;- as.factor(categorical_vector, levels=c(\"Male\", \"Female\"))\n\n\n\n\n\nclass(a) where a &lt;- FALSE: Checking the class of a logical FALSE value.\nis.numeric(x) and is.character(x): Checking if a variable is numeric or character.\nas.numeric(c)*x where c &lt;- \"2\" and x &lt;- 2: Converting a character to numeric and then multiplying by another numeric value.\n\n\n\n\n\nis.factor(murders$region): Checks if the region column in the murders dataframe is a factor.\nfactor_data &lt;- factor(data): Converts the data vector into a factor.\ncountry_income_factor &lt;- factor(country_income, ordered=TRUE, levels=c(\"low\",\"middle\",\"high\")): Creates an ordered factor variable country_income_factor with specified levels indicating the ordering.\n\n\n\n\n\n\n\n\nmy_df &lt;- murders[1:10,]: This line creates a new dataframe my_df that consists of the first 10 rows of the murders dataframe.\ndf &lt;- data.frame(c1, c2): This code creates a dataframe named df with columns c1 and c2 from the vectors provided.\ndata.frame(): Combines vectors into a data frame, columns must be of equal length.\nrownames(): Assigns names to the rows of the data frame.\n\n\nmy_data_frame &lt;- data.frame(my_calories, my_friends_calories)\nrownames(my_data_frame) &lt;- days \n\nA data frame is created from two vectors and row names are assigned.\n\n\n\n\nmy_list &lt;- list(my_vector, my_matrix, my_df): This creates a list my_list containing a vector, a matrix, and a dataframe.\nnames(my_list) &lt;- listnames: Assigns names to the elements of the my_list.\nmy_list$df: Accesses the dataframe component named df in my_list.\n\n\n\n\n\nmy_data_frame[1:3, 1]: Indexes specific rows and columns.\nmy_data_frame$my_calories: Retrieves a column as a vector.\n\n\nmy_data_frame_subset &lt;- my_data_frame[1:3, 1] # Selects the first three rows of the first column\nmy_column &lt;- my_data_frame$my_calories # Retrieves a single column from the data frame\n\nSubsetting a data frame to retrieve specific rows/columns and accessing a single column as a vector.\n\nsubset(murders, subset= state==\"Alabama\"): Subsets the murders dataframe to include only rows where state is “Alabama”.\nover20M &lt;- subset(murders, subset= population &gt; 20000000): Subsets the murders dataframe to include only rows where the population is greater than 20 million.\n\n\n\n\n\nmurders[murders$region == \"South\", ]: Retrieves rows based on a condition.\n\n\nsouthern_states &lt;- murders[murders$region == \"South\", ] # Retrieves rows where the region is 'South'\n\nThis code demonstrates how to subset a data frame based on a condition.\n\n\n\n\norder(murders$population): This function returns the indices of the population column in the murders dataframe in ascending order.\nmurders[order(murders$population),]: This command reorders the murders dataframe in ascending order based on the population column.\nmurders[order(murders$population, decreasing = TRUE),]: This variant of the order function sorts the murders dataframe in descending order based on the population column.\n\n\n\n\n\n\n\n\ngeom_histogram(): Creates a histogram.\ngeom_point(): Creates a scatter plot.\ngeom_bar(): Creates a bar plot.\n\n\nggplot(murders) + aes(x=population) + geom_histogram() # Creates a histogram\nggplot(murders) + aes(x=population, y=total) + geom_point() # Creates a scatter plot\nggplot(murders) + aes(x=region) + geom_bar() # Creates a bar plot\n\nEach line of code creates a different type of plot using the ggplot2 package, one of the most powerful visualization packages in R.\n\n\n\n\nLabels and Colors: geom_label(), coloring by color=region.\nScaling: scale_x_continuous(), scale_y_continuous() for logarithmic transformations.\n\n\nggplot(murders) + aes(x=population, y=total, label=abb, color=region) + geom_label()\nggplot(murders) + aes(x=population, y=total) + geom_point() +\n    scale_x_continuous(trans=\"log10\") + scale_y_continuous(trans=\"log10\")\n\nThis code block illustrates how to add labels and colors to the points in a plot, and how to transform axes scales.\n\nggplot(murders, aes(total)) + geom_histogram(binwidth = 20): Creates a histogram, but specifies a binwidth of 20, controlling the size of the bins used in the histogram.\nTitles and Labels: xlab(), ggtitle() for custom labels and titles.\n\n\nggplot(murders) + aes(x=population/1000000, y=total) + geom_point() + xlab(\"Population in millions\") + ggtitle(\"Number of murders vs population in US states\")\n\nThis line demonstrates how to label the axes and add a title to a plot for better understanding of the presented data.\n\n\n\nBasic ggplot2 Plotting:\n\nggplot(murders): Initializes a ggplot object with the murders dataset.\nclass(p): Determines the class of the object p.\nView(p): Opens the RStudio viewer to display the object p, which would be a ggplot object.\nggplot(murders, aes(x=population, y=total)) + geom_point(): Creates a scatter plot of total vs population from the murders dataset.\n\nAdding Labels and Colors:\n\nggplot(murders, aes(population, total)) + geom_label(aes(population, total, label=abb)) # Adds labels to the plot, specified by the abb column in the `murders` dataset\nggplot(murders, aes(population, total)) + geom_label(aes(population, total, label=abb), color=\"blue\") # Same as above but sets the label color to blue\n\n\nggplot(murders, aes(population, total)) + geom_label(aes(population, total, label=abb, color=region)) # Adds labels and uses the region column to color-code them\n\nGlobal Aesthetic Mappings:\n\np &lt;- ggplot(murders, aes(population, total, label=abb, color=region)) # Defines a global aesthetic mapping for the population, total, abb, and region which can be used with further layers added to the plot\n\n\np + geom_label() # Adds label layers to the base plot `p`\np + geom_point(size=2, color=\"purple\") + geom_text() # Adds both points and text layers to the plot, with specific aesthetic modifications\n\nScale Transformations and Titles:\n\np + geom_point(size=2, color=\"purple\") + geom_text() + scale_x_continuous(trans=\"log10\") # Transforms the x-axis to a log10 scale while adding points and text layers\np + geom_point(size=2, color=\"purple\") + geom_text() + scale_x_continuous(trans=\"log10\") + scale_y_continuous(trans=\"log10\") # Transforms both axes to log10 scales\n\n\np + geom_point(size=2, color=\"purple\") + geom_text() + scale_x_continuous(trans=\"log10\") + scale_y_continuous(trans=\"log10\") + ggtitle(\"Gun Murders and Population Size in US\") # Adds a title to the plot\n\nModifying Labels and Axis Text:\n\np + geom_point(size=2, color=\"purple\") + geom_text() + scale_x_continuous(trans=\"log10\") + scale_y_continuous(trans=\"log10\") + ggtitle(\"Gun Murders and Population Size in US\") + xlab(\"Population in millions (log scaled)\") + ylab(\"Total gun murders (log scaled)\") # Sets custom labels for the axes\n\nBar Plots and Coordinate Flipping:\n\nggplot(murders, aes(state, total/population*1000)) + geom_col() # Creates a bar plot of states with the bars representing total murders per 1000 in population\nggplot(murders, aes(state, total/population*1000)) + geom_col() + coord_flip() # Same as above but with horizontal bars\n\n\nggplot(murders, aes(reorder(state, total/population*1000), total/population*1000)) + geom_col() + coord_flip() # Reorders the states in the bar plot based on the murder rate, with horizontal bars\n\nThese codes represent the basics of using ggplot2 for creating different types of visualizations such as scatter plots and bar plots, including adding various layers, setting global aesthetics, scaling axes, and flipping coordinates. These are fundamental techniques when creating data visualizations in R with ggplot2.\n\n\n\n\nsmaller &lt;- subset(diamonds, subset=carat &lt;= 2.5): Creates a subset of the diamonds data where the carat size is less than or equal to 2.5.\nggplot(smaller, aes(carat)) + geom_freqpoly(binwidth = 0.01): Plots a frequency polygon of the carat distribution for the smaller subset of diamonds, with a bin width of 0.01.\nggplot(diamonds, aes(carat, price)) + geom_point(): Creates a scatter plot showing the relationship between carat and price. There may be a positive correlation between the two variables, but this relationship may weaken with larger carats.\nggplot(diamonds, aes(carat, price)) + geom_point() + facet_grid(.~cut): Generates a scatter plot of carat versus price, faceted by the cut of the diamonds. This allows the analysis to compare the relationship across different cuts, noting variations in the strength of the relationship.\nggplot(diamonds, aes(carat, price, color=color)) + geom_point() + facet_grid(.~cut): Similar to the previous plot, but this time the points are colored based on the color of the diamonds. The plot explores how diamond color may influence price, indicating that diamonds with a more whitish color may command higher prices for the same size.\n\n\n\n\n\n\n\n\nsummary(): Provides a full summary of a variable.\nmean(): Calculates the mean of a variable.\ntapply(): Applies a function (like summary) over subsets of a vector, indexed by some other vector (like regions).\n\n\nsummary(murders$population) # Provides a full summary statistics(min, 1st quartile, median, mean, 3rd quartile, and max) for the population column in murders dataset\nmean(murders$population) # Calculates the mean of the population column.\n\n\ntapply(murders$population, murders$region, summary) # Applies the `summary` function to the `population` column within each `region`, providing statistical summaries for each region.\n\n\ntapply(murders$total, murders$region, mean) # Applies the `mean` function to the `total` column within each `region`, calculating the average number of murders by region.\ntapply(murders$total, murders$region, summary) # Applies the `summary` function to the `total` column within each `region`, providing statistical summaries for each region.\n\nThese functions are used to calculate summary statistics for vectors and subsets of data within vectors."
  },
  {
    "objectID": "about.html#creation-and-naming",
    "href": "about.html#creation-and-naming",
    "title": "Cheat Sheet",
    "section": "",
    "text": "c(): Combines elements into a vector.\nnames(): Assigns names to vector elements for easier indexing.\n\n\ndays &lt;- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\")\nmy_calories &lt;- c(100, 120, 200, 150, 140)\nnames(my_calories) &lt;- days # Assigns names to the elements in the 'my_calories' vector\n\nThis code creates two vectors: one for days and one for calorie count. It then assigns the names of the days as labels for the calorie counts."
  },
  {
    "objectID": "about.html#vector-operations",
    "href": "about.html#vector-operations",
    "title": "Cheat Sheet",
    "section": "",
    "text": "By position: my_calories[1] retrieves the first element.\nBy name: my_calories[\"Monday\"] retrieves the element named “Monday”.\nBy range: my_calories[1:3] retrieves the first three elements.\n\n\nfirst_three_days &lt;- my_calories[1:3] # Selects the first three elements\nmy_calories_monday &lt;- my_calories[\"Monday\"] # Selects the element named \"Monday\"\n\nThis demonstrates how to retrieve specific elements from a vector, either by their position or by their assigned names.\n\nmy_exp[c(1,3)] or my_exp[c(\"MON\",\"WED\")]: Accessing multiple elements using numeric or named indices. Retrieves the first and third elements or retrieves the element named “MON” and “WED”.\n\n\n\n\n\nmy_calories[my_calories &gt;= 150] retrieves elements meeting the condition.\n\n\nmy_good_days &lt;- my_calories[my_calories &gt;= 150] # Selects days with calorie counts of 150 or more\n\nThis is used to create a subset of my_calories where the condition (calories &gt;= 150) is true."
  },
  {
    "objectID": "about.html#vector-merging",
    "href": "about.html#vector-merging",
    "title": "Cheat Sheet",
    "section": "",
    "text": "The c() function is used again to merge two separate vectors into a single vector.\n\nmy_friends_calories &lt;- c(200, 130, 100, 170, 150)\nall_calories &lt;- c(my_calories, my_friends_calories): Combines two vectors into one.\n\n\n\n\nmy_calories &lt;- my_calories + 50: Adding 50 to each element of my_calories vector.\nweekly_calories &lt;- sum(my_calories): Summing all elements of my_calories to get weekly_calories, the total calories."
  },
  {
    "objectID": "about.html#creation",
    "href": "about.html#creation",
    "title": "Cheat Sheet",
    "section": "Creation",
    "text": "Creation\n\nmatrix(): Creates a matrix from the provided vector.\nncol, byrow: Specifies the number of columns and whether to fill the matrix by rows."
  },
  {
    "objectID": "about.html#naming",
    "href": "about.html#naming",
    "title": "Cheat Sheet",
    "section": "Naming",
    "text": "Naming\n\nrownames(), colnames(): Assigns names to the rows and columns of a matrix.\n\n\ncalories_matrix &lt;- matrix(all_calories, ncol=2, byrow=FALSE)\nrownames(calories_matrix) &lt;- days # Sets the row names of the matrix.\ncolnames(calories_matrix) &lt;- c(\"me\", \"my_friend\") # Sets the column names of the matrix.\n\nThis code block shows how to convert a vector into a matrix and then assign row and column names for better readability."
  },
  {
    "objectID": "about.html#factor-creation",
    "href": "about.html#factor-creation",
    "title": "Cheat Sheet",
    "section": "Factor Creation",
    "text": "Factor Creation\n\nas.factor(): Converts a vector into a factor, useful for categorical data.\nlevels: Specifies the levels of the factor.\n\n\ncategorical_vector &lt;- c(\"Male\", \"Female\", \"Female\")\ncategorical_vector_as_factor &lt;- as.factor(categorical_vector, levels=c(\"Male\", \"Female\"))"
  },
  {
    "objectID": "about.html#creation-1",
    "href": "about.html#creation-1",
    "title": "Cheat Sheet",
    "section": "Creation",
    "text": "Creation\n\ndata.frame(): Combines vectors into a data frame, columns must be of equal length.\nrownames(): Assigns names to the rows of the data frame.\n\n\nmy_data_frame &lt;- data.frame(my_calories, my_friends_calories)\nrownames(my_data_frame) &lt;- days \n\nA data frame is created from two vectors and row names are assigned."
  },
  {
    "objectID": "about.html#indexing-and-retrieval",
    "href": "about.html#indexing-and-retrieval",
    "title": "Cheat Sheet",
    "section": "Indexing and Retrieval",
    "text": "Indexing and Retrieval\n\nmy_data_frame[1:3, 1]: Indexes specific rows and columns.\nmy_data_frame$my_calories: Retrieves a column as a vector.\n\n\nmy_data_frame_subset &lt;- my_data_frame[1:3, 1] # Selects the first three rows of the first column\nmy_column &lt;- my_data_frame$my_calories # Retrieves a single column from the data frame\n\nSubsetting a data frame to retrieve specific rows/columns and accessing a single column as a vector."
  },
  {
    "objectID": "about.html#conditional-retrieval",
    "href": "about.html#conditional-retrieval",
    "title": "Cheat Sheet",
    "section": "Conditional Retrieval",
    "text": "Conditional Retrieval\n\nmurders[murders$region == \"South\", ]: Retrieves rows based on a condition.\n\n\nsouthern_states &lt;- murders[murders$region == \"South\", ] # Retrieves rows where the region is 'South'\n\nThis code demonstrates how to subset a data frame based on a condition."
  },
  {
    "objectID": "about.html#plot-types",
    "href": "about.html#plot-types",
    "title": "Cheat Sheet",
    "section": "Plot Types",
    "text": "Plot Types\n\ngeom_histogram(): Creates a histogram.\ngeom_point(): Creates a scatter plot.\ngeom_bar(): Creates a bar plot.\n\n\nggplot(murders) + aes(x=population) + geom_histogram() # Creates a histogram\nggplot(murders) + aes(x=population, y=total) + geom_point() # Creates a scatter plot\nggplot(murders) + aes(x=region) + geom_bar() # Creates a bar plot\n\nEach line of code creates a different type of plot using the ggplot2 package, one of the most powerful visualization packages in R."
  },
  {
    "objectID": "about.html#enhancements",
    "href": "about.html#enhancements",
    "title": "Cheat Sheet",
    "section": "Enhancements",
    "text": "Enhancements\n\nLabels and Colors: geom_label(), coloring by color=region.\nScaling: scale_x_continuous(), scale_y_continuous() for logarithmic transformations.\n\n\nggplot(murders) + aes(x=population, y=total, label=abb, color=region) + geom_label()\nggplot(murders) + aes(x=population, y=total) + geom_point() +\n    scale_x_continuous(trans=\"log10\") + scale_y_continuous(trans=\"log10\")\n\nThis code block illustrates how to add labels and colors to the points in a plot, and how to transform axes scales.\n\nTitles and Labels: xlab(), ggtitle() for custom labels and titles.\n\n\nggplot(murders) + aes(x=population/1000000, y=total) + geom_point() + xlab(\"Population in millions\") + ggtitle(\"Number of murders vs population in US states\")\n\nThis line demonstrates how to label the axes and add a title to a plot for better understanding of the presented data."
  },
  {
    "objectID": "about.html#summary-functions",
    "href": "about.html#summary-functions",
    "title": "Cheat Sheet",
    "section": "Summary Functions",
    "text": "Summary Functions\n\nsummary(): Provides a full summary of a variable.\nmean(): Calculates the mean of a variable.\ntapply(): Applies a function (like summary) over subsets of a vector, indexed by some other vector (like regions).\n\n\nsummary(murders$population) # Provides a full summary statistics for the population column\nmean(murders$population) # Calculates the mean of the population column\ntapply(murders$population, murders$region, summary) # Applies the summary function to subsets of population based on the region\n\nThese functions are used to calculate summary statistics for vectors and subsets of data within vectors."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Overview",
    "section": "",
    "text": "Create vectors by combining elements using the c() function.\n\nthink of c() function for combine; you are combining things together.\n\n\n\n\n\n\n\nc()\n\n\n\n\nc(element1, element2, element3, ...)\n\nCombines given elements to a vector.\n\n\n\n\n\n\n\n\nRemember, by definition, all elements in a vector must have the same type(integer, double, character, logical etc.).\n\n\n\nLets create a 5 element vector of week-days and assign this vector to variable days.\n\ndays &lt;- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\")\ndays \n\n[1] \"Monday\"    \"Tuesday\"   \"Wednesday\" \"Thursday\"  \"Friday\"   \n\n\nEssentially you have just created a typical Excel column of a table. When you think about it a table is just a combination of vectors!\n\n\n\ndays\n…\n…\n\n\n\n\nMonday\n…\n…\n\n\nTuesday\n…\n…\n\n\nWednesday\n…\n…\n\n\nThursday\n…\n…\n\n\nFriday\n…\n…\n\n\n\nNotice all the elements(names of the days) are the same type(character). In this case days is a character vector.\nLets add two other columns to this table and create them in R; the calories burned by you (me) and the calories burned by your friend(my friend) for each day.\n\nBurn the Calories competition results\n\n\ndays\nmy calories\nmy friend calories\n\n\n\n\nMonday\n100\n200\n\n\nTuesday\n120\n130\n\n\nWednesday\n200\n100\n\n\nThursday\n150\n170\n\n\nFriday\n140\n150\n\n\n\nThis table shows the calories burned for you and your friend for different days.\nNow, we need to create the other two columns (my calories, and my friend calories) in R. Just like days we can create vectors for each column. This time the elements are numeric, so we are going to be creating a numeric vector\n\n\n\n\n\n\nExercise\n\n\n\nCreate a vector for the calories burned by you (represented in the my calories column) and assign it to variable named my_calories\n\n\nShow the code\nmy_calories = c(100, 120, 200, 150, 140)\nmy_calories \n\n\n[1] 100 120 200 150 140\n\n\nCreate a vector for the calories burned by your friend(in my friend calories column). Assing it to variable my_friends_calories\n\n\nShow the code\nmy_friends_calories &lt;- c(200,130,100,170,150)\nmy_friends_calories \n\n\n[1] 200 130 100 170 150\n\n\n\n\nNow we can see the days,\n\ndays\n\n[1] \"Monday\"    \"Tuesday\"   \"Wednesday\" \"Thursday\"  \"Friday\"   \n\n\nthe calories you burned,\n\nmy_calories\n\n[1] 100 120 200 150 140\n\n\nand the calories your friend burned\n\nmy_friends_calories\n\n[1] 200 130 100 170 150\n\n\nSuppose your friend came up to you and asked how many calories you burned on Thursday. Remember you only have the variables days, my_calories and my_friends_calories. What would be your answer?\nTo answer this question you would use the varaible my_calories that contains the calories you burned each day:\n\nmy_calories\n\n[1] 100 120 200 150 140\n\n\nBut this variable only contains the calories burned by you as values, it doesn’t have the names of the week you burned the calories. However, you know that the first value(100) is the calories burned by you in monday, so you can count the days until thursday to find the correct answer: 150.\nThis is kind of a hard work. It is hard to tell how many calories you burned on which day and it would have been nice to see the days of the names when we are looking at the vector my_calories.\nA result like this would be great:\n\nmy_calories\n\n   Monday   Tuesday Wednesday  Thursday    Friday \n      100       120       200       150       140 \n\n\nIn fact, this is very simple to do with R: you can use the function names() to assign a name to each element of a vector.\n\n\n\n\n\n\nnames()\n\n\n\nThis function allows you to check, change, and delete the names of a varaible.\nTo check the names of a vector use:\n\nnames(aVectorName)\n\nTo change the names of a vector, use:\n\nnames(aVectorName) &lt;- anotherVectorThatIncludesNames\n\nTo remove the names of a vector, use:\n\nnames(aVectorName) &lt;- NULL\n\n\n\nCurrently we dont have any names for any value of our vector my_calories. Lets confirm this:\n\nnames(my_calories)\n\nNULL\n\n\nWe have the result NULL, which indicates no element in our vector has a name.\nWhat we want is to name each element by their corresponding days. So the first element of my_calories (100) should be named Monday, the second (120) should be named Thursday etc. To do that we can assign a new vector which contains the names of each element to names(my_calories):\n\nnames(my_calories) &lt;- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\")\n\n\n\n\n\n\n\nTip: You can use a varaible to name a vector\n\n\n\n\n\nThere was an easier way to do this naming operation. Instead of creating a new vector of names we could have used the varaible days which has the same values!\nSo the following code:\n\nnames(my_calories) &lt;- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\")\n\nis exactly same as this code\n\nnames(my_calories) &lt;- days\n\nThis is because days\n\ndays\n\n[1] \"Monday\"    \"Tuesday\"   \"Wednesday\" \"Thursday\"  \"Friday\"   \n\n\nis the same as this:\n\nc(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\")\n\n[1] \"Monday\"    \"Tuesday\"   \"Wednesday\" \"Thursday\"  \"Friday\"   \n\n\n\n\n\nNow lets see how does our variable look like:\n\nmy_calories\n\n   Monday   Tuesday Wednesday  Thursday    Friday \n      100       120       200       150       140 \n\n\n\n\n\n\n\n\nTip: To remove the names of a vector assing NULL to its names\n\n\n\n\n\nIf we want to remove the names of our vector my_calories we can assign the names of the vector to what it was: NULL\n\nnames(my_calories) &lt;- NULL\n\nlets check:\n\nmy_calories\n\n[1] 100 120 200 150 140\n\n\n\n\n\nNow we have one variable days which contains the names of the days, my_calories which contains the calories you burned, and it is a named vector, and my_friends_calories which contains the calories burned by your friend and it is not named.\n\n\n\n\n\n\nExercise\n\n\n\nTables have turned, it is your time to ask your friend a question. You ask him how many calories he burned on Wednesday.\nWell he told you the true answer: 100. However, your friend didn’t take a BUS220 course before and he first check his variable:\n\nmy_friends_calories\n\n[1] 200 130 100 170 150\n\n\nThen counted to the 3rd value.\nBut you know better. Show him how to do this professionally:\n\nName his burned calories to their corresponding days:\n\n\n\nShow the code\nnames(my_friends_calories) &lt;- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\")\n\n\nor following code is another way to do it:\n\n\nShow the code\n# if you did this way, you are a cool person (⌐■_■)\nnames(my_friends_calories) &lt;- days\n\n\n\nShow him how his variable look like now:\n\n\n\nShow the code\nmy_friends_calories\n\n\n   Monday   Tuesday Wednesday  Thursday    Friday \n      200       130       100       170       150 \n\n\n\nAnnoy your friend; remove the names of the his variable, let him suffer in his ignorance.\n\n\n\nShow the code\nnames(my_friends_calories) &lt;- NULL\n\n\n\n\nYour annoying friend has another question for you now: How many calories did you burn in your first three days?\nTo answer that you need to use my_calories vector:\n\nmy_calories\n\n   Monday   Tuesday Wednesday  Thursday    Friday \n      100       120       200       150       140 \n\n\nFrom here you can simply give the answer to your friend. However, you don’t want to share the calories you burned on other days(Thursday and Friday). So, you don’t need the whole vector, you only need a ‘subset’ of your vector(a part of your vector, a portion of your vector) which shows only the first three days.\nTo do that you can use what is called indexing. Indexing is reaching certain elements of a variable, in this case a vector.\n\n\n\n\n\n\nIndexing Syntax\n\n\n\nUse vectorName[n] to reach the nth value of the number.\nvectorName[1]: returns the first element of the vector. vectorName[2]: returns the first element of the vector.\nUse vectorName[-n] to get elements except the nth. vectorName[-1] returns all elements except the first vectorName[-6] returns all elements except the 6th element.\nWe can also use a vector of positions to reach only to those positions. This is called slicing. vectorName[n1:n2] will give you all the items between the positions n1 and n2.\nvectorName[1:2]: returns 1st and 2nd elements(same as above) vectorName[c(1, 2)]: returns 1st and 2nd elements. vectorName[c(1, 3, 6)] returns 1st, 3rd and 6th elements. vectorName[1:50] returns all elements between 1st and 50th positions.\nYou can also use logical vectors for slicing as well. This becomes more like filtering actually: vectorName[condition] gives you the vector elements that satisfy the condition given vectorName[vectorName &gt; 4] returns all the elements that are bigger than 4 vectorName[vectorName &lt;= 4] returns all the elements that are less or equal to 4\n\n\nTo reach to a certain elements of a vector, you first need to determine the positions of the elements. For your case you need to reach the first 3 elements of the vector my_calories. So your the position of the elements you want to reach is 1st, 2nd, and third.\nAfter this you can use [] to index your varaible. Putting your positions inside the squared braces before your variable name will result with what you want\n\nmy_calories[c(1, 2, 3)]\n\n   Monday   Tuesday Wednesday \n      100       120       200 \n\n\n\n\n\n\n\n\nTip: alternative way to do this\n\n\n\n\n\nThere is a cooler way (⌐■_■) to do this. Can you guess how?\n\n\nShow the code\nmy_calories[1:3]\n\n\n   Monday   Tuesday Wednesday \n      100       120       200 \n\n\nThis works because what you put inside the [] are the same!\nCheck this:\n\n\nShow the code\n1:3\n\n\n[1] 1 2 3\n\n\nand this:\n\n\nShow the code\nc(1, 2, 3)\n\n\n[1] 1 2 3\n\n\nthey are the same, so you end up with the same result!\n\n\n\nLets get the calories you burned on thursday:\n\nmy_calories[4] \n\nThursday \n     150 \n\n# Thursday is the 4th day, so we write 4 to reach \n# to the 4th value\n\nIf the elements of your variable have names (just like your my_calories) you can also use name of the element instead of the position to reach certain elements. Everything else is the same; you just write the name of the element instead of the position.\nWhy don’t you give a try this time: reach the calories burned by you for friday\n\n\nShow the code\nmy_calories[\"Friday\"]\n\n\nFriday \n   140 \n\n\nYou can also combine names just like positions: 1. Reach the calories burned by you on tuesday and thursday using positions of the elements\n\n\nShow the code\nmy_calories[c(2, 4)]\n\n\n Tuesday Thursday \n     120      150 \n\n\n\nDo the same but use the names instead of the positions\n\n\n\nShow the code\nmy_calories[c(\"Tuesday\", \"Thursday\")]\n\n\n Tuesday Thursday \n     120      150 \n\n\nNow your annoyed friend comes back and asks you another question:\n\nOn which days did you burn more than 120 calories?\n\nLets see your variable again:\n\nmy_calories\n\n   Monday   Tuesday Wednesday  Thursday    Friday \n      100       120       200       150       140 \n\n\nWe can tell by looking at this. We burned more than 120 calories on wednesday, thursday, and friday.\nBut R doesn’t have eyes, or brains, so we need to guide R to see and think just like we do. Lets consider how we found our answer:\n\nWe understood that we have a condition. Our element must be more than 120 (&gt;120).\nStarting from 100 (Monday) we evaluated if each value about whether they satisfy the condition (if it is higher than 120) or not (if it is not higher than 120).\nFor the values that satisfied our condition(wednesday, thursday, friday) we took a note in our head, for the elements that doesn’t we ignored them and gave the answer.\n\nturns out R also works like this. We give a condition to R ( &gt; 120) (or &gt; 0 etc) and R goes to each element, checks whether the element is fit for the condition and returns only the elements that satisfy our condition.\nSo lets do this in R way. We are trying to reach the eleemnts that are higher than 120. This is our condition; so we need our varaible my_calories to be more than 120. Lets write this and see what happens\n\nmy_calories &gt; 120\n\n   Monday   Tuesday Wednesday  Thursday    Friday \n    FALSE     FALSE      TRUE      TRUE      TRUE \n\n\nR did what we did! It went to each value in the vector and evaluated the condition( &gt; 120). Here how this worked: 1. R goes to first value: 100, asks the question “Does this value satisfy the condition?”. The answer is no. So it took a note: FALSE(computer language for no). 2. Next, R went to the second value; 120. Asked itself “Does this value satisfy the condition?”. FALSE. It also noted this down. 3. R went to the 3rd value; 200. Asked the same question. This time the answer is yes, 200 is higher than 120. So it took a note TRUE (yes for computer language). 4. same as above 5. same as above.\nR goes to each valeu in the vector, evaluates whether they satisfy the condition or not and then returns a vector showing us the results.\nNow these results are not really what we wanted. We only see the days you burned more than 120 calories but we dont see the actaul calories themselves. To see them we do inexing just like we did with the positions;\n\nmy_calories[my_calories &gt; 120]\n\nWednesday  Thursday    Friday \n      200       150       140 \n\n\nNow we got what we wanted.\n\n\n\n\n\n\nExercise\n\n\n\nTables turned: now you ask your friend the questions. Ask him:\n\nHow much calories you burned on Tuesday(2nd day) and Friday(5th day)\n\nagain, he solves it amateurly; counts the days and so forth.\n\nmy_friends_calories\n\n[1] 200 130 100 170 150\n\n\nYou now better, show him how it is done. (Notice we don’t have names in this variable. So we cannot use names to index)\n\n\nShow the code\nmy_friends_calories[c(2, 5)]\n\n\n[1] 130 150\n\n\n\nHow much calories you burned on last 3 days?\n\n\n\nShow the code\nmy_friends_calories[3:5]\n\n\n[1] 100 170 150\n\n\n\nOn the days you burned more than 130 calories, how many calories you burned?\n\n\n\nShow the code\nmy_friends_calories[my_friends_calories &gt; 130]\n\n\n[1] 200 170 150\n\n\n\nDid you less than 130 calories a day? If so how many did you burn?\n\n\n\nShow the code\nmy_friends_calories[my_friends_calories &lt; 130]\n\n\n[1] 100\n\n\n\nHave you ever burned exactly 150 calories?\n\nTip: use == (two equal signs) Tip: This is not an indexing question. A yes(TRUE) or no (FALSE) question.\n\n\nShow the code\nmy_friends_calories == 150\n\n\n[1] FALSE FALSE FALSE FALSE  TRUE\n\n\n\n\nFinally, lets end this section by combining the calories burned by you and your friend. Our old friend c() function combines elements right? So, can it combine two vectors?\nLets try one example first; 1:4 is a vector right? Just like c(5, 40, 400). The question is can we combine these two vectors?\n\nc(1:4, c(5, 40, 400))\n\n[1]   1   2   3   4   5  40 400\n\n\nYes! c() function can combine vectors together to one (this is called flattening among computer nerds).\nSo how about if you try to combine the calories you and your friend burned into one vector and assing it to a variable named all_calories:\n\nall_calories &lt;- c(my_calories, my_friends_calories)\nall_calories\n\n   Monday   Tuesday Wednesday  Thursday    Friday                               \n      100       120       200       150       140       200       130       100 \n                    \n      170       150 \n\n\nNotice the names for your calories stayed and since your friends vector was not named we don’t see any name for their values. Well this looks ugly, remove the names of all elements:\n\nnames(all_calories) &lt;- NULL\nall_calories\n\n [1] 100 120 200 150 140 200 130 100 170 150\n\n\nNice."
  },
  {
    "objectID": "index.html#creating-a-data-frame",
    "href": "index.html#creating-a-data-frame",
    "title": "Overview",
    "section": "Creating a Data Frame",
    "text": "Creating a Data Frame\nTo create a data frame you need 3 things;\n\nVectors of equal length to bind into the columns (just like in matrices, we ned them column to be filled big time.)\nthe holy data.frame(column1, column2, ...) function. (as you can see you just put the vectors side by side as columns).\na will to continue this to this part.(you sure you have this? Yeah, I didn’t think so.)\n\nLets prepare the first thing, bunch of vectors to combine (think of this as excel table. We need to create the columns first to have the table right? (thumbs up if you hate excel))\nOkay the task is yours; we are going to create the following table(data frame). But first we need to create the columns sepearetly as vectors( we did this at chapter Vectors):\n\n\n\ntitle\nyear\nlength\nview\n\n\n\n\nMovie_a\n1997\n121\n787\n\n\nMovie_b\n1980\n124\n534\n\n\nMovie_c\n1983\n133\n572\n\n\nMovie_d\n1999\n133\n1027\n\n\nMovie_e\n2002\n142\n657\n\n\nMovie_f\n2005\n140\n849\n\n\nMovie_g\n2015\n135\n2059\n\n\n\nFirst create the title vector. I’ll help with this, don’t worry about the code, it produces what we want. If you be a good person you ll write these code by yourself one day in addition to being able to see the smurfs.\n\ntitle &lt;- paste(\"Movie\", 1:7, sep = \"_\")\ntitle\n\n[1] \"Movie_1\" \"Movie_2\" \"Movie_3\" \"Movie_4\" \"Movie_5\" \"Movie_6\" \"Movie_7\"\n\n\n\n\nShow the code\nyear &lt;- c(1997,1980,1983,1999,2002,2005,2015)\nyear\n\n\n[1] 1997 1980 1983 1999 2002 2005 2015\n\n\n\n\nShow the code\nlength &lt;-c(121,124,133,133,142,140,135)\nlength\n\n\n[1] 121 124 133 133 142 140 135\n\n\n\n\nShow the code\nview &lt;- c(787,534,572,1027,657,849,2059)\nview\n\n\n[1]  787  534  572 1027  657  849 2059\n\n\nNow we have each column to combine to a data frame; it is time to use data.frame() function which takes argument of columns. Create a data frame named movies shown on the table above\n\nmovies &lt;- data.frame(title, year, length, view)\nmovies\n\n    title year length view\n1 Movie_1 1997    121  787\n2 Movie_2 1980    124  534\n3 Movie_3 1983    133  572\n4 Movie_4 1999    133 1027\n5 Movie_5 2002    142  657\n6 Movie_6 2005    140  849\n7 Movie_7 2015    135 2059\n\n\nNotice the row numbers are generated automatically, they don’t hurt.\nWhy dont we use a matrix instead? Try creating this as a matrix instead. Yeah, thats right: a matrix takes only one vector as input and this means you need to combine all values here to a vector. But that wont work because we have different types of values here(some numeric some character) (it actually works but in a bad way. You dont even want to know about it. So be happy with your ignorance and continue…(for the sceptists out there you can try to merge all these columns using c function. (c(title, year,…) then use it in the matrix function. But are you ready to try this? are you ready for the blue pill?))).\nData frames are fun, they are easy and you will work with them 99% of the time if you go forward with R.\nLets see a few tricks:\nSubsetting(or indexing) is the same as matrices. So for example Get the title column:\n\nmovies[, \"title\"]\n\n[1] \"Movie_1\" \"Movie_2\" \"Movie_3\" \"Movie_4\" \"Movie_5\" \"Movie_6\" \"Movie_7\"\n\n\n\n# or\nmovies[, 1]\n\n[1] \"Movie_1\" \"Movie_2\" \"Movie_3\" \"Movie_4\" \"Movie_5\" \"Movie_6\" \"Movie_7\"\n\n\nWell there is an easier way to reach to a column with data frames. Use this syntax: dataframe$column.\nFor example the same thing can be done via:\n\nmovies$title\n\n[1] \"Movie_1\" \"Movie_2\" \"Movie_3\" \"Movie_4\" \"Movie_5\" \"Movie_6\" \"Movie_7\"\n\n\nlooks weird, doesn’t seem like easier? Well it is, get used to it.\n\n\n\n\n\n\nExercise\n\n\n\nWhat is the length of Movie_3?\n\n\nShow the code\nmovies[3, \"length\"] # 3rd value of the length column\n\n\n[1] 133\n\n\nShow the code\n# or\nmovies$length[3] # 3rd value of the length column\n\n\n[1] 133\n\n\nGet the year column\n\n\nShow the code\nmovies$year\n\n\n[1] 1997 1980 1983 1999 2002 2005 2015\n\n\nGet the first 3 rows and last 2 columns of the data frame\n\n\nShow the code\nmovies[1:3, 2:4]\n\n\n  year length view\n1 1997    121  787\n2 1980    124  534\n3 1983    133  572\n\n\nso, same as matrices.\n\n\nNote that there is no difference between dataframe$column and dataframe[,\"column\"].\n\nmovies[,\"year\"]\n\n[1] 1997 1980 1983 1999 2002 2005 2015\n\n\n\nmovies$year\n\n[1] 1997 1980 1983 1999 2002 2005 2015\n\n\nbut you can return the column as data frame just by adding drop = FALSE after your selection. Really handy stuff I tell you.\n\nmovies[,\"year\", drop = F]\n\n  year\n1 1997\n2 1980\n3 1983\n4 1999\n5 2002\n6 2005\n7 2015"
  },
  {
    "objectID": "index.html#names-of-data-frames",
    "href": "index.html#names-of-data-frames",
    "title": "Overview",
    "section": "Names of Data Frames",
    "text": "Names of Data Frames\nData frames have row and column names. use the functions you used to get the row and column names:\n\nrownames(movies)\n\n[1] \"1\" \"2\" \"3\" \"4\" \"5\" \"6\" \"7\"\n\n\n\ncolnames(movies)\n\n[1] \"title\"  \"year\"   \"length\" \"view\"  \n\n\n99% of the time you will work with colnames and they are very important to master. You can assign new names by assigning a new vector to the column names\n\ncolnames(movies) &lt;- c(\"name\", \"prod.Year\", \"duration\", \"seen\")\nmovies\n\n     name prod.Year duration seen\n1 Movie_1      1997      121  787\n2 Movie_2      1980      124  534\n3 Movie_3      1983      133  572\n4 Movie_4      1999      133 1027\n5 Movie_5      2002      142  657\n6 Movie_6      2005      140  849\n7 Movie_7      2015      135 2059\n\n\nWe can do filtering for the data frames. For example say you want to select movies after 2000. How to do that? Well there is two ways to do this; easy way, hard way. Ofcourse we start with the unnecessary but gives you good inshight about the way R works, a.k.a hard way; using our beloved []\nLets think about this; we want to see the movies fow which the production year is at least 2000.\nFirst do it with your eyes. Look at this data frame and picture the result\n\nmovies\n\n     name prod.Year duration seen\n1 Movie_1      1997      121  787\n2 Movie_2      1980      124  534\n3 Movie_3      1983      133  572\n4 Movie_4      1999      133 1027\n5 Movie_5      2002      142  657\n6 Movie_6      2005      140  849\n7 Movie_7      2015      135 2059\n\n\nIf you weren’t able to here is the correct results\n\n\n     name prod.Year duration seen\n5 Movie_5      2002      142  657\n6 Movie_6      2005      140  849\n7 Movie_7      2015      135 2059\n\n\nSo how do we go from that to this?\nLets once again see how do we do it in our brain?\nFirst we know we have a condition: prod.Year column should be at least 2000. Lets firt reach to this colum using $\n\n\nShow the code\nmovies$prod.Year\n\n\n[1] 1997 1980 1983 1999 2002 2005 2015\n\n\nnow lets write our condiiton; prod Year &gt;= 2000\n\n\nShow the code\nmovies$prod.Year &gt; 2000\n\n\n[1] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n\n\nR went to each value in prod.Year and checked the condition. If the value satisfied the condition it noted as TRUE and if it the value did not satisfy the condition it noted as FALSE. We see that the first 4 values are lower than 2000 so they are marked as FALSE and others as TRUE.\nNow we don’t want false and true values, we want a data frame with the condions applied. To do that we need to take this condition and apply it to the rows of the data frame. As you know the rows are in the first part of the [rows, columns]. So we need to put this condition to first part of the squared braces to filter these rows with FALSE value. Lets see:\n\nmovies[movies$prod.Year &gt;= 2000, ]\n\n     name prod.Year duration seen\n5 Movie_5      2002      142  657\n6 Movie_6      2005      140  849\n7 Movie_7      2015      135 2059\n\n\nwe make sure to put a comma for the columns and since we want all the columns we leave that part blank. However we could for example take only the name and duration of these movies:\n\nmovies[movies$prod.Year &gt;= 2000, c(\"name\", \"duration\")]\n\n     name duration\n5 Movie_5      142\n6 Movie_6      140\n7 Movie_7      135\n\n\n\n\n\n\n\n\nExercise\n\n\n\nDo you remember our table of calories burned? create the data frame of it. The name of the data frame should be my_data_frame.\nPlease don’t crete the columns again. You already have them: days, my_calories…\n\n\n\ndays\nmy calories\nmy friend calories\n\n\n\n\nMonday\n100\n200\n\n\nTuesday\n120\n130\n\n\nWednesday\n200\n100\n\n\nThursday\n150\n170\n\n\nFriday\n140\n150\n\n\n\ncreate the data frame\n\n\nShow the code\nmy_data_frame &lt;- data.frame(days, my_calories, my_friends_calories)\nmy_data_frame\n\n\n               days my_calories my_friends_calories\nMonday       Monday         100                 200\nTuesday     Tuesday         120                 130\nWednesday Wednesday         200                 100\nThursday   Thursday         150                 170\nFriday       Friday         140                 150\n\n\nCheck the rownames\n\n\nShow the code\nrownames(my_data_frame)\n\n\n[1] \"Monday\"    \"Tuesday\"   \"Wednesday\" \"Thursday\"  \"Friday\"   \n\n\nremove the rownames\n\n\nShow the code\nrownames(my_data_frame) &lt;- NULL\n\n\ncheck the data frame again:\n\n\nShow the code\nmy_data_frame\n\n\n       days my_calories my_friends_calories\n1    Monday         100                 200\n2   Tuesday         120                 130\n3 Wednesday         200                 100\n4  Thursday         150                 170\n5    Friday         140                 150\n\n\ncheck the column names\n\n\nShow the code\ncolnames(my_data_frame) \n\n\n[1] \"days\"                \"my_calories\"         \"my_friends_calories\"\n\n\nleave them be.\nfilter the data frame for the days you burned less calories than 140:\n\nwhat is your condition?\n\n\n\nShow the code\nmy_data_frame$my_calories &lt; 140\n\n\n[1]  TRUE  TRUE FALSE FALSE FALSE\n\n\n\napply it to the rows of the data frame\n\n\n\nShow the code\nmy_data_frame[my_data_frame$my_calories &lt; 140,]\n\n\n     days my_calories my_friends_calories\n1  Monday         100                 200\n2 Tuesday         120                 130\n\n\nokay kind of a hard one, filter the data frames for the values when you burned more calories than your friend\n\nwhat is your condition?\n\n\n\nShow the code\nmy_data_frame$my_calories &gt; my_data_frame$my_friends_calories\n\n\n[1] FALSE FALSE  TRUE FALSE FALSE\n\n\n\napply it to the rows of the data frame\n\n\n\nShow the code\nmy_data_frame[my_data_frame$my_calories &gt; my_data_frame$my_friends_calories,]\n\n\n       days my_calories my_friends_calories\n3 Wednesday         200                 100\n\n\nnice."
  },
  {
    "objectID": "index.html#data-frame-statistics",
    "href": "index.html#data-frame-statistics",
    "title": "Overview",
    "section": "Data Frame Statistics",
    "text": "Data Frame Statistics\nSome functions are very handy to summarise information about a data frame; these include but not limited to:\nsummary() summarises basic statistics about each column in your data frame.\n\nsummary(movies)\n\n     name             prod.Year       duration          seen       \n Length:7           Min.   :1980   Min.   :121.0   Min.   : 534.0  \n Class :character   1st Qu.:1990   1st Qu.:128.5   1st Qu.: 614.5  \n Mode  :character   Median :1999   Median :133.0   Median : 787.0  \n                    Mean   :1997   Mean   :132.6   Mean   : 926.4  \n                    3rd Qu.:2004   3rd Qu.:137.5   3rd Qu.: 938.0  \n                    Max.   :2015   Max.   :142.0   Max.   :2059.0  \n\n\ndim() shows you how many rows and columns you have; first one is the rows(guess the second one.)\n\ndim(movies)\n\n[1] 7 4\n\n\nWell you can have that info and more using str(); which, in addition to row and column numbers(observations are the number of rows; guess the variables.)\n\nstr(movies)\n\n'data.frame':   7 obs. of  4 variables:\n $ name     : chr  \"Movie_1\" \"Movie_2\" \"Movie_3\" \"Movie_4\" ...\n $ prod.Year: num  1997 1980 1983 1999 2002 ...\n $ duration : num  121 124 133 133 142 140 135\n $ seen     : num  787 534 572 1027 657 ...\n\n\nso prod.Year is a numeric varaible and we see its first 5 values.\nSometimes we have really long data frames. And we only want to see the first 6 rows. Than we use head()\n\nhead(movies)\n\n     name prod.Year duration seen\n1 Movie_1      1997      121  787\n2 Movie_2      1980      124  534\n3 Movie_3      1983      133  572\n4 Movie_4      1999      133 1027\n5 Movie_5      2002      142  657\n6 Movie_6      2005      140  849\n\n\nWhat if we want to see the last 6, then use tail()\n\ntail(movies)\n\n     name prod.Year duration seen\n2 Movie_2      1980      124  534\n3 Movie_3      1983      133  572\n4 Movie_4      1999      133 1027\n5 Movie_5      2002      142  657\n6 Movie_6      2005      140  849\n7 Movie_7      2015      135 2059\n\n\nView() is also a very nice function you should try at home, at your own risk.\n\nView(movies)"
  },
  {
    "objectID": "about.html#introduction",
    "href": "about.html#introduction",
    "title": "Cheat Sheet",
    "section": "",
    "text": "getwd(): Retrieves the current working directory path.\ninstall.packages(\"tidyverse\"): Installs the tidyverse package.\ninstall.packages(\"dslabs\"): Installs the dslabs package.\nlibrary(tidyverse): Loads the tidyverse package, a collection of R packages designed for data science.\nlibrary(dslabs): Loads the dslabs package, which contains datasets and functions for data science.\nlibrary(ggplot2): Loads the ggplot2 package for creating plots.\ndata(murders): Loads the murders dataset available in the dslabs package."
  },
  {
    "objectID": "about.html#matrices-operations",
    "href": "about.html#matrices-operations",
    "title": "Cheat Sheet",
    "section": "Matrices Operations",
    "text": "Matrices Operations\nLet’s first create a matrix again.\n\nsw_matrix &lt;- matrix(sw, nrow = 3, byrow = TRUE): #Creating a matrix sw_matrix from the sw vector, filling the matrix by rows.\nrownames(sw_matrix) &lt;- titles: #Setting row names of the matrix sw_matrix.\ncolnames(sw_matrix) &lt;- regions: #Setting column names of the matrix sw_matrix.\ncolSums(sw_matrix) and rowSums(sw_matrix): #Calculating the sum of columns and rows in sw_matrix.\nsw_matrix2 &lt;- cbind(sw_matrix, worldwide): #Binding a new column worldwide to the sw_matrix to form sw_matrix2.\nsw2 &lt;- matrix(box_office2, nrow = 3, byrow=TRUE): #Creating another matrix sw2.\nallsw &lt;- rbind(sw_matrix, sw2): #Combining two matrices by rows, resulting in allsw."
  },
  {
    "objectID": "about.html#matrices",
    "href": "about.html#matrices",
    "title": "Cheat Sheet",
    "section": "",
    "text": "matrix(): Creates a matrix from the provided vector.\nncol, byrow: Specifies the number of columns and whether to fill the matrix by rows.\nmy_matrix &lt;- matrix(1:9, ncol = 3): Constructs a 3x3 matrix with a sequence of numbers from 1 to 9.\n\n\n\n\n\nrownames(), colnames(): Assigns names to the rows and columns of a matrix.\n\n\ncalories_matrix &lt;- matrix(all_calories, ncol=2, byrow=FALSE)\nrownames(calories_matrix) &lt;- days # Sets the row names of the matrix.\ncolnames(calories_matrix) &lt;- c(\"me\", \"my_friend\") # Sets the column names of the matrix.\n\nThis code block shows how to convert a vector into a matrix and then assign row and column names for better readability.\n\n\n\nLet’s first create a matrix again.\n\nsw_matrix &lt;- matrix(sw, nrow = 3, byrow = TRUE): Creating a matrix sw_matrix from the sw vector, filling the matrix by rows.\nrownames(sw_matrix) &lt;- titles: Setting row names of the matrix sw_matrix.\ncolnames(sw_matrix) &lt;- regions: Setting column names of the matrix sw_matrix.\n\nSummation;\n\ncolSums(sw_matrix) and rowSums(sw_matrix): Calculating the sum of columns and rows in sw_matrix.\nsw_matrix2 &lt;- cbind(sw_matrix, worldwide): Binding a new column worldwide to the sw_matrix to form sw_matrix2.\n\nCombining;\n\nsw2 &lt;- matrix(box_office2, nrow = 3, byrow=TRUE): Creating another matrix sw2.\nallsw &lt;- rbind(sw_matrix, sw2): Combining two matrices by rows, resulting in allsw."
  },
  {
    "objectID": "about.html#factors",
    "href": "about.html#factors",
    "title": "Cheat Sheet",
    "section": "",
    "text": "as.factor(): Converts a vector into a factor, useful for categorical data.\nlevels: Specifies the levels of the factor.\n\n\ncategorical_vector &lt;- c(\"Male\", \"Female\", \"Female\")\ncategorical_vector_as_factor &lt;- as.factor(categorical_vector, levels=c(\"Male\", \"Female\"))\n\n\n\n\n\nclass(a) where a &lt;- FALSE: Checking the class of a logical FALSE value.\nis.numeric(x) and is.character(x): Checking if a variable is numeric or character.\nas.numeric(c)*x where c &lt;- \"2\" and x &lt;- 2: Converting a character to numeric and then multiplying by another numeric value.\n\n\n\n\n\nis.factor(murders$region): Checks if the region column in the murders dataframe is a factor.\nfactor_data &lt;- factor(data): Converts the data vector into a factor.\ncountry_income_factor &lt;- factor(country_income, ordered=TRUE, levels=c(\"low\",\"middle\",\"high\")): Creates an ordered factor variable country_income_factor with specified levels indicating the ordering."
  },
  {
    "objectID": "about.html#data-frames",
    "href": "about.html#data-frames",
    "title": "Cheat Sheet",
    "section": "",
    "text": "my_df &lt;- murders[1:10,]: This line creates a new dataframe my_df that consists of the first 10 rows of the murders dataframe.\ndf &lt;- data.frame(c1, c2): This code creates a dataframe named df with columns c1 and c2 from the vectors provided.\ndata.frame(): Combines vectors into a data frame, columns must be of equal length.\nrownames(): Assigns names to the rows of the data frame.\n\n\nmy_data_frame &lt;- data.frame(my_calories, my_friends_calories)\nrownames(my_data_frame) &lt;- days \n\nA data frame is created from two vectors and row names are assigned.\n\n\n\n\nmy_list &lt;- list(my_vector, my_matrix, my_df): This creates a list my_list containing a vector, a matrix, and a dataframe.\nnames(my_list) &lt;- listnames: Assigns names to the elements of the my_list.\nmy_list$df: Accesses the dataframe component named df in my_list.\n\n\n\n\n\nmy_data_frame[1:3, 1]: Indexes specific rows and columns.\nmy_data_frame$my_calories: Retrieves a column as a vector.\n\n\nmy_data_frame_subset &lt;- my_data_frame[1:3, 1] # Selects the first three rows of the first column\nmy_column &lt;- my_data_frame$my_calories # Retrieves a single column from the data frame\n\nSubsetting a data frame to retrieve specific rows/columns and accessing a single column as a vector.\n\nsubset(murders, subset= state==\"Alabama\"): Subsets the murders dataframe to include only rows where state is “Alabama”.\nover20M &lt;- subset(murders, subset= population &gt; 20000000): Subsets the murders dataframe to include only rows where the population is greater than 20 million.\n\n\n\n\n\nmurders[murders$region == \"South\", ]: Retrieves rows based on a condition.\n\n\nsouthern_states &lt;- murders[murders$region == \"South\", ] # Retrieves rows where the region is 'South'\n\nThis code demonstrates how to subset a data frame based on a condition.\n\n\n\n\norder(murders$population): This function returns the indices of the population column in the murders dataframe in ascending order.\nmurders[order(murders$population),]: This command reorders the murders dataframe in ascending order based on the population column.\nmurders[order(murders$population, decreasing = TRUE),]: This variant of the order function sorts the murders dataframe in descending order based on the population column."
  },
  {
    "objectID": "about.html#ggplot-for-data-visualization",
    "href": "about.html#ggplot-for-data-visualization",
    "title": "Cheat Sheet",
    "section": "",
    "text": "geom_histogram(): Creates a histogram.\ngeom_point(): Creates a scatter plot.\ngeom_bar(): Creates a bar plot.\n\n\nggplot(murders) + aes(x=population) + geom_histogram() # Creates a histogram\nggplot(murders) + aes(x=population, y=total) + geom_point() # Creates a scatter plot\nggplot(murders) + aes(x=region) + geom_bar() # Creates a bar plot\n\nEach line of code creates a different type of plot using the ggplot2 package, one of the most powerful visualization packages in R.\n\n\n\n\nLabels and Colors: geom_label(), coloring by color=region.\nScaling: scale_x_continuous(), scale_y_continuous() for logarithmic transformations.\n\n\nggplot(murders) + aes(x=population, y=total, label=abb, color=region) + geom_label()\nggplot(murders) + aes(x=population, y=total) + geom_point() +\n    scale_x_continuous(trans=\"log10\") + scale_y_continuous(trans=\"log10\")\n\nThis code block illustrates how to add labels and colors to the points in a plot, and how to transform axes scales.\n\nggplot(murders, aes(total)) + geom_histogram(binwidth = 20): Creates a histogram, but specifies a binwidth of 20, controlling the size of the bins used in the histogram.\nTitles and Labels: xlab(), ggtitle() for custom labels and titles.\n\n\nggplot(murders) + aes(x=population/1000000, y=total) + geom_point() + xlab(\"Population in millions\") + ggtitle(\"Number of murders vs population in US states\")\n\nThis line demonstrates how to label the axes and add a title to a plot for better understanding of the presented data.\n\n\n\nBasic ggplot2 Plotting:\n\nggplot(murders): Initializes a ggplot object with the murders dataset.\nclass(p): Determines the class of the object p.\nView(p): Opens the RStudio viewer to display the object p, which would be a ggplot object.\nggplot(murders, aes(x=population, y=total)) + geom_point(): Creates a scatter plot of total vs population from the murders dataset.\n\nAdding Labels and Colors:\n\nggplot(murders, aes(population, total)) + geom_label(aes(population, total, label=abb)) # Adds labels to the plot, specified by the abb column in the `murders` dataset\nggplot(murders, aes(population, total)) + geom_label(aes(population, total, label=abb), color=\"blue\") # Same as above but sets the label color to blue\n\n\nggplot(murders, aes(population, total)) + geom_label(aes(population, total, label=abb, color=region)) # Adds labels and uses the region column to color-code them\n\nGlobal Aesthetic Mappings:\n\np &lt;- ggplot(murders, aes(population, total, label=abb, color=region)) # Defines a global aesthetic mapping for the population, total, abb, and region which can be used with further layers added to the plot\n\n\np + geom_label() # Adds label layers to the base plot `p`\np + geom_point(size=2, color=\"purple\") + geom_text() # Adds both points and text layers to the plot, with specific aesthetic modifications\n\nScale Transformations and Titles:\n\np + geom_point(size=2, color=\"purple\") + geom_text() + scale_x_continuous(trans=\"log10\") # Transforms the x-axis to a log10 scale while adding points and text layers\np + geom_point(size=2, color=\"purple\") + geom_text() + scale_x_continuous(trans=\"log10\") + scale_y_continuous(trans=\"log10\") # Transforms both axes to log10 scales\n\n\np + geom_point(size=2, color=\"purple\") + geom_text() + scale_x_continuous(trans=\"log10\") + scale_y_continuous(trans=\"log10\") + ggtitle(\"Gun Murders and Population Size in US\") # Adds a title to the plot\n\nModifying Labels and Axis Text:\n\np + geom_point(size=2, color=\"purple\") + geom_text() + scale_x_continuous(trans=\"log10\") + scale_y_continuous(trans=\"log10\") + ggtitle(\"Gun Murders and Population Size in US\") + xlab(\"Population in millions (log scaled)\") + ylab(\"Total gun murders (log scaled)\") # Sets custom labels for the axes\n\nBar Plots and Coordinate Flipping:\n\nggplot(murders, aes(state, total/population*1000)) + geom_col() # Creates a bar plot of states with the bars representing total murders per 1000 in population\nggplot(murders, aes(state, total/population*1000)) + geom_col() + coord_flip() # Same as above but with horizontal bars\n\n\nggplot(murders, aes(reorder(state, total/population*1000), total/population*1000)) + geom_col() + coord_flip() # Reorders the states in the bar plot based on the murder rate, with horizontal bars\n\nThese codes represent the basics of using ggplot2 for creating different types of visualizations such as scatter plots and bar plots, including adding various layers, setting global aesthetics, scaling axes, and flipping coordinates. These are fundamental techniques when creating data visualizations in R with ggplot2.\n\n\n\n\nsmaller &lt;- subset(diamonds, subset=carat &lt;= 2.5): Creates a subset of the diamonds data where the carat size is less than or equal to 2.5.\nggplot(smaller, aes(carat)) + geom_freqpoly(binwidth = 0.01): Plots a frequency polygon of the carat distribution for the smaller subset of diamonds, with a bin width of 0.01.\nggplot(diamonds, aes(carat, price)) + geom_point(): Creates a scatter plot showing the relationship between carat and price. There may be a positive correlation between the two variables, but this relationship may weaken with larger carats.\nggplot(diamonds, aes(carat, price)) + geom_point() + facet_grid(.~cut): Generates a scatter plot of carat versus price, faceted by the cut of the diamonds. This allows the analysis to compare the relationship across different cuts, noting variations in the strength of the relationship.\nggplot(diamonds, aes(carat, price, color=color)) + geom_point() + facet_grid(.~cut): Similar to the previous plot, but this time the points are colored based on the color of the diamonds. The plot explores how diamond color may influence price, indicating that diamonds with a more whitish color may command higher prices for the same size."
  },
  {
    "objectID": "about.html#statistical-summaries",
    "href": "about.html#statistical-summaries",
    "title": "Cheat Sheet",
    "section": "",
    "text": "summary(): Provides a full summary of a variable.\nmean(): Calculates the mean of a variable.\ntapply(): Applies a function (like summary) over subsets of a vector, indexed by some other vector (like regions).\n\n\nsummary(murders$population) # Provides a full summary statistics(min, 1st quartile, median, mean, 3rd quartile, and max) for the population column in murders dataset\nmean(murders$population) # Calculates the mean of the population column.\n\n\ntapply(murders$population, murders$region, summary) # Applies the `summary` function to the `population` column within each `region`, providing statistical summaries for each region.\n\n\ntapply(murders$total, murders$region, mean) # Applies the `mean` function to the `total` column within each `region`, calculating the average number of murders by region.\ntapply(murders$total, murders$region, summary) # Applies the `summary` function to the `total` column within each `region`, providing statistical summaries for each region.\n\nThese functions are used to calculate summary statistics for vectors and subsets of data within vectors."
  },
  {
    "objectID": "about.html#vectors",
    "href": "about.html#vectors",
    "title": "Cheat Sheet",
    "section": "",
    "text": "c(): Combines elements into a vector.\nnames(): Assigns names to vector elements for easier indexing.\n\n\ndays &lt;- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\")\nmy_calories &lt;- c(100, 120, 200, 150, 140)\nnames(my_calories) &lt;- days # Assigns names to the elements in the `my_calories` vector\n\nThis code creates two vectors: one for days and one for calorie count. It then assigns the names of the days as labels for the calorie counts.\n\nmy_vector &lt;- c(1:10): Creates a vector containing a sequence from 1 to 10.\n\n\n\n\n\nBy position: my_calories[1] retrieves the first element.\nBy name: my_calories[\"Monday\"] retrieves the element named “Monday”.\nBy range: my_calories[1:3] retrieves the first three elements.\n\n\nfirst_three_days &lt;- my_calories[1:3] # Selects the first three elements\nmy_calories_monday &lt;- my_calories[\"Monday\"] # Selects the element named \"Monday\"\n\nThis demonstrates how to retrieve specific elements from a vector, either by their position or by their assigned names.\n\nmy_exp[c(1,3)] or my_exp[c(\"MON\",\"WED\")]: Accessing multiple elements using numeric or named indices. Retrieves the first and third elements or retrieves the element named “MON” and “WED”.\n\n\n\n\n\nmy_calories[my_calories &gt;= 150] retrieves elements meeting the condition.\n\n\nmy_good_days &lt;- my_calories[my_calories &gt;= 150] # Selects days with calorie counts of 150 or more\n\nThis is used to create a subset of my_calories where the condition (calories &gt;= 150) is true.\n\n\n\nThe c() function is used again to merge two separate vectors into a single vector.\n\nmy_friends_calories &lt;- c(200, 130, 100, 170, 150)\nall_calories &lt;- c(my_calories, my_friends_calories): Combines two vectors into one.\n\n\n\n\n\nmy_calories &lt;- my_calories + 50: Adding 50 to each element of my_calories vector.\nweekly_calories &lt;- sum(my_calories): Summing all elements of my_calories to get weekly_calories, the total calories."
  }
]